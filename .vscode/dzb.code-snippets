{
  "genHooks": {
    "prefix": "genHooks",
    "body": [
      "import { useEffect, useState, useCallback, useRef } from 'react';",
      "import cloneDeep from 'lodash/cloneDeep';",
      "import { isArray, isEmpty } from 'lodash';",
      "import { useSave } from 'stores/useStore';",
      "import { showError } from 'helpers/toast';",
      "",
      "import { Todo } from 'interfaces/todo';",
      "import todoService, { RequestGetToDoList, ResponseToDoList } from 'services/todoService';",
      "",
      "/********************************************************",
      " * SNIPPET GENERATED",
      " * GUIDE",
      " * Snippet for infinite scroll with page + rowsPerPage",
      " * Maybe you should check function:",
      " * - interface Request / Response",
      " * - parseRequest",
      " * - checkConditionPass",
      " * - fetch",
      " * - refetch",
      " ********************************************************/",
      "",
      "//* Check parse body request",
      "const parseRequest = (filters: RequestGetToDoList) => {",
      "  return cloneDeep({",
      "    page: filters.page,",
      "    rowsPerPage: filters.rowsPerPage,",
      "  });",
      "};",
      "",
      "const MAX_COUNT_RETRY_REQUEST = 3;",
      "",
      "const $1 = (",
      "  filters: RequestGetToDoList,",
      "  options: { isTrigger?: boolean; refetchKey?: string } = { isTrigger: true, refetchKey: '' }",
      ") => {",
      "  //! State",
      "  const { isTrigger = true, refetchKey = '' } = options;",
      "",
      "  const save = useSave();",
      "  const countRequest = useRef(0);",
      "  const [data, setData] = useState<Todo[]>([]);",
      "  const [loading, setLoading] = useState(false);",
      "  const [refetching, setRefetching] = useState(false);",
      "  const [error, setError] = useState<unknown>(null);",
      "  const [hasMore, setHasMore] = useState(false);",
      "",
      "  //! Function",
      "  const fetch: () => Promise<ResponseToDoList> | undefined = useCallback(() => {",
      "    if (!isTrigger) {",
      "      return;",
      "    }",
      "",
      "    return new Promise((resolve, reject) => {",
      "      (async () => {",
      "        try {",
      "          const nextFilters = parseRequest(filters);",
      "          const response = await todoService.getTodoList(nextFilters);",
      "          countRequest.current = 0;",
      "          resolve(response);",
      "        } catch (error) {",
      "          if (countRequest.current < MAX_COUNT_RETRY_REQUEST) {",
      "            countRequest.current = countRequest.current + 1;",
      "            fetch();",
      "          } else {",
      "            countRequest.current = 0;",
      "            setError(error);",
      "            reject(error);",
      "          }",
      "        }",
      "      })();",
      "    });",
      "  }, [filters, isTrigger]);",
      "",
      "  const checkConditionPass = useCallback((response: ResponseToDoList) => {",
      "    //* Check condition of response here to set data",
      "    if (isArray(response?.data)) {",
      "      setData(response?.data);",
      "      setHasMore(!isEmpty(response?.data));",
      "    }",
      "  }, []);",
      "",
      "  //* Refetch implicity (without changing loading state)",
      "  const refetch = useCallback(async () => {",
      "    try {",
      "      setRefetching(true);",
      "      const response = await fetch();",
      "      if (response) {",
      "        checkConditionPass(response);",
      "      }",
      "",
      "      setRefetching(false);",
      "    } catch (error: any) {",
      "      if (!error.isCanceled) {",
      "        showError(error);",
      "      }",
      "    }",
      "  }, [fetch, checkConditionPass]);",
      "",
      "  useEffect(() => {",
      "    save(refetchKey, refetch);",
      "  }, [save, refetchKey, refetch]);",
      "",
      "  //* Refetch with changing loading state",
      "  const refetchWithLoading = useCallback(async () => {",
      "    try {",
      "      setLoading(true);",
      "      const response = await fetch();",
      "      if (response) {",
      "        checkConditionPass(response);",
      "      }",
      "      setLoading(false);",
      "    } catch (error) {",
      "      showError(error);",
      "      setLoading(false);",
      "    }",
      "  }, [fetch, checkConditionPass]);",
      "",
      "  //* Main handler",
      "  useEffect(() => {",
      "    let shouldSetData = true;",
      "",
      "    //* Fetch initial API",
      "    const fetchAPI = async () => {",
      "      try {",
      "        setLoading(true);",
      "        const response = await fetch();",
      "        if (shouldSetData && response) {",
      "          checkConditionPass(response);",
      "          setLoading(false);",
      "        }",
      "      } catch (error) {",
      "        showError(error);",
      "        setLoading(false);",
      "      }",
      "    };",
      "",
      "    fetchAPI();",
      "",
      "    return () => {",
      "      shouldSetData = false;",
      "    };",
      "  }, [fetch, checkConditionPass]);",
      "",
      "  return {",
      "    data,",
      "    loading,",
      "    error,",
      "    refetch,",
      "    refetchWithLoading,",
      "    refetching,",
      "    hasMore,",
      "    setData,",
      "  };",
      "};",
      "",
      "export default $1;",
      ""
    ],
    "description": "genHooks"
  },
  "genHooksInifiniteScroll": {
    "prefix": "genHooksInifiniteScroll",
    "body": [
      "import { useEffect, useState, useCallback, useRef } from 'react';",
      "import cloneDeep from 'lodash/cloneDeep';",
      "import { flatten, isArray, isEmpty } from 'lodash';",
      "import { useSave } from 'stores/useStore';",
      "import { showError } from 'helpers/toast';",
      "",
      "import { Todo } from 'interfaces/todo';",
      "import todoService, { RequestGetToDoList, ResponseToDoList } from 'services/todoService';",
      "",
      "/********************************************************",
      " * SNIPPET GENERATED",
      " * GUIDE",
      " * Snippet for infinite scroll with page + rowsPerPage",
      " * Maybe you should check function:",
      " * - interface Request / Response",
      " * - parseRequest",
      " * - checkConditionPass",
      " * - fetch",
      " * - refetch",
      " ********************************************************/",
      "",
      "//* Check parse body request",
      "const parseRequest = (filters: RequestGetToDoList) => {",
      "  return cloneDeep({",
      "    page: filters.page,",
      "    rowsPerPage: filters.rowsPerPage,",
      "  });",
      "};",
      "",
      "const MAX_COUNT_RETRY_REQUEST = 3;",
      "",
      "const $1 = (",
      "  filters: RequestGetToDoList,",
      "  options: { isTrigger?: boolean; refetchKey?: string } = { isTrigger: true, refetchKey: '' }",
      ") => {",
      "  //! State",
      "  const { isTrigger = true, refetchKey = '' } = options;",
      "",
      "  const save = useSave();",
      "  const countRequest = useRef(0);",
      "  const [data, setData] = useState<Todo[]>([]);",
      "  const [loading, setLoading] = useState(false);",
      "  const [refetching, setRefetching] = useState(false);",
      "  const [loadingMore, setLoadingMore] = useState(false);",
      "  const [error, setError] = useState<unknown>(null);",
      "  const [hasMore, setHasMore] = useState(false);",
      "",
      "  //! Function",
      "  const fetch: () => Promise<ResponseToDoList> | undefined = useCallback(() => {",
      "    if (!isTrigger) {",
      "      return;",
      "    }",
      "",
      "    return new Promise((resolve, reject) => {",
      "      (async () => {",
      "        try {",
      "          const nextFilters = parseRequest(filters);",
      "          const response = await todoService.getTodoList(nextFilters);",
      "          countRequest.current = 0;",
      "          resolve(response);",
      "        } catch (error) {",
      "          if (countRequest.current < MAX_COUNT_RETRY_REQUEST) {",
      "            countRequest.current = countRequest.current + 1;",
      "            fetch();",
      "          } else {",
      "            countRequest.current = 0;",
      "            setError(error);",
      "            reject(error);",
      "          }",
      "        }",
      "      })();",
      "    });",
      "  }, [filters, isTrigger]);",
      "",
      "  const checkConditionPass = useCallback(",
      "    (response: ResponseToDoList, options: { isLoadmore?: boolean } = {}) => {",
      "      const { isLoadmore } = options;",
      "",
      "      //* Check condition of response here to set data",
      "      if (isArray(response?.data)) {",
      "        if (isLoadmore) {",
      "          setData((prev) => {",
      "            let nextPages = cloneDeep(prev);",
      "            nextPages = [...(nextPages || []), ...(response?.data || [])];",
      "            return nextPages;",
      "          });",
      "        } else {",
      "          setData(response?.data);",
      "        }",
      "",
      "        setHasMore(!isEmpty(response?.data));",
      "      }",
      "    },",
      "    [filters.rowsPerPage]",
      "  );",
      "",
      "  //* Refetch implicity (without changing loading state)",
      "  const refetch = useCallback(async () => {",
      "    try {",
      "      setRefetching(true);",
      "      const page = filters?.page || 1;",
      "",
      "      let listRequest: Promise<ResponseToDoList>[] = [];",
      "      for (let eachPage = 0; eachPage < page; eachPage++) {",
      "        const nextFilters = parseRequest(filters);",
      "        nextFilters.page = eachPage;",
      "",
      "        const request = todoService.getTodoList(nextFilters);",
      "",
      "        listRequest = [...listRequest, request];",
      "      }",
      "",
      "      const responses = await Promise.allSettled(listRequest);",
      "      const allData = responses.map((el) => {",
      "        if (el.status === 'fulfilled') {",
      "          return isArray(el?.value?.data) ? el?.value?.data : [];",
      "        }",
      "",
      "        return [];",
      "      });",
      "      setData(flatten(allData));",
      "      setRefetching(false);",
      "    } catch (error: any) {",
      "      if (!error.isCanceled) {",
      "        showError(error);",
      "      }",
      "    }",
      "  }, [filters]);",
      "",
      "  useEffect(() => {",
      "    save(refetchKey, refetch);",
      "  }, [save, refetchKey, refetch]);",
      "",
      "  //* Refetch with changing loading state",
      "  const refetchWithLoading = useCallback(async () => {",
      "    try {",
      "      setLoading(true);",
      "      const response = await fetch();",
      "      if (response) {",
      "        checkConditionPass(response);",
      "      }",
      "      setLoading(false);",
      "    } catch (error) {",
      "      showError(error);",
      "      setLoading(false);",
      "    }",
      "  }, [fetch, checkConditionPass]);",
      "",
      "  useEffect(() => {",
      "    let shouldSetData = true;",
      "",
      "    //* Fetch initial API",
      "    const fetchAPI = async () => {",
      "      try {",
      "        setLoading(true);",
      "        const response = await fetch();",
      "        if (shouldSetData && response) {",
      "          checkConditionPass(response);",
      "          setLoading(false);",
      "        }",
      "      } catch (error) {",
      "        showError(error);",
      "        setLoading(false);",
      "      }",
      "    };",
      "",
      "    //* Fetch more API",
      "    const fetchMore = async () => {",
      "      setLoadingMore(true);",
      "      const response = await fetch();",
      "      if (shouldSetData && response) {",
      "        checkConditionPass(response, { isLoadmore: true });",
      "      }",
      "",
      "      setLoadingMore(false);",
      "    };",
      "",
      "    if (filters.page !== undefined && filters.page <= 0) {",
      "      fetchAPI();",
      "    } else {",
      "      //* If page / offset > 0 -> fetch more",
      "      fetchMore();",
      "    }",
      "",
      "    return () => {",
      "      shouldSetData = false;",
      "    };",
      "  }, [filters.page, fetch, checkConditionPass]);",
      "",
      "  return {",
      "    data,",
      "    loading,",
      "    error,",
      "    refetch,",
      "    refetchWithLoading,",
      "    refetching,",
      "    loadingMore,",
      "    hasMore,",
      "    setData,",
      "  };",
      "};",
      "",
      "export default $1;"
    ],
    "description": "genHooksInifiniteScroll"
  },
  "genComponentTable": {
    "prefix": "genComponentTable",
    "body": [
      "import React from 'react';",
      "import CommonIcons from 'components/CommonIcons';",
      "import CommonStyles from 'components/CommonStyles';",
      "import SearchAndFilters from 'components/SearchAndFilters';",
      "import { FastField } from 'formik';",
      "import TextField from 'components/CustomFields/TextField';",
      "import useFiltersHandler from 'hooks/useFiltersHandler';",
      "import { Order } from 'interfaces/common';",
      "",
      "interface $1Props {}",
      "",
      "const initialValues = {",
      "  username: '',",
      "  email: '',",
      "  page: 0,",
      "  rowsPerPage: 5,",
      "  order: Order.desc,",
      "  orderBy: '',",
      "};",
      "",
      "const $1 = (props: $1Props) => {",
      "  //! State",
      "  const {",
      "    filters,",
      "    setFilters,",
      "    selected,",
      "    handleChangePage,",
      "    handleChangeRowsPerPage,",
      "    handleRequestSort,",
      "    handleSelectAllClick,",
      "    handleResetToInitial,",
      "    handleCheckBox,",
      "  } = useFiltersHandler(initialValues);",
      "",
      "  //! Function",
      "  const totalCount = 2;",
      "",
      "  const data = [",
      "    {",
      "      id: '1',",
      "      name: 'Pham Quy Don',",
      "      email: 'donezombie@gmail.com',",
      "    },",
      "    {",
      "      id: '2',",
      "      name: 'Pham Quy Don 2',",
      "      email: 'donezombie2@gmail.com',",
      "    },",
      "  ];",
      "",
      "  //! Render",
      "  return (",
      "    <CommonStyles.Box>",
      "      <CommonStyles.Typography variant='h4' sx={{ mb: 3 }}>",
      "        $1 management",
      "      </CommonStyles.Typography>",
      "",
      "      <CommonStyles.Typography sx={{ mb: 2 }}>",
      "        <code style={{ backgroundColor: 'rgba(0, 0, 0, 0.1)', padding: 12 }}>",
      "          {JSON.stringify({ filters: { ...filters, selected } })}",
      "        </code>",
      "      </CommonStyles.Typography>",
      "",
      "      <SearchAndFilters",
      "        initialValues={initialValues}",
      "        onSubmit={(values) => {",
      "          setFilters(values);",
      "        }}",
      "        onReset={() => {",
      "          handleResetToInitial();",
      "        }}",
      "        renderFilterFields={() => {",
      "          return (",
      "            <CommonStyles.Box sx={{ gap: 2, display: 'flex' }}>",
      "              <FastField",
      "                component={TextField}",
      "                name='username'",
      "                placeholder='Username'",
      "                label='Username'",
      "              />",
      "              <FastField component={TextField} name='email' placeholder='Email' label='Email' />",
      "            </CommonStyles.Box>",
      "          );",
      "        }}",
      "      />",
      "",
      "      <CommonStyles.Box sx={{ mt: 3 }}>",
      "        <CommonStyles.Typography variant='h6' sx={{ mb: 1 }}>",
      "          Total record(s): {totalCount}",
      "        </CommonStyles.Typography>",
      "        <CommonStyles.Table",
      "          order={filters?.order || Order.desc}",
      "          orderBy={filters?.orderBy}",
      "          selected={selected}",
      "          page={filters?.page || 0}",
      "          rowsPerPage={filters?.rowsPerPage || 5}",
      "          headCells={[",
      "            {",
      "              label: 'Name',",
      "              id: 'name',",
      "            },",
      "            {",
      "              label: 'Email',",
      "              id: 'email',",
      "            },",
      "          ]}",
      "          totalCount={totalCount}",
      "          rows={data}",
      "          handleChangePage={handleChangePage}",
      "          handleChangeRowsPerPage={handleChangeRowsPerPage}",
      "          handleRequestSort={handleRequestSort}",
      "          handleSelectAllClick={handleSelectAllClick}",
      "          handleCheckBox={handleCheckBox}",
      "          showCheckBox",
      "        />",
      "      </CommonStyles.Box>",
      "    </CommonStyles.Box>",
      "  );",
      "};",
      "",
      "export default React.memo($1);",
      ""
    ],
    "description": "genComponentTable"
  },
  "genComponent": {
    "prefix": "genComponent",
    "body": [
      "import React from 'react';",
      "import classNames from 'classnames';",
      "import CommonIcons from 'components/CommonIcons';",
      "import CommonStyles from 'components/CommonStyles';",
      "",
      "interface $1Props {}",
      "",
      "const $1 = (props: $1Props) => {",
      "  //! State",
      "",
      "  //! Function",
      "",
      "  //! Render",
      "  return <CommonStyles.Box className={classNames('component:$1')}>$1</CommonStyles.Box>;",
      "};",
      "",
      "export default React.memo($1);",
      ""
    ],
    "description": "genComponent"
  },
  "genDialog": {
    "prefix": "genDialog",
    "body": [
      "import DialogMui from '@mui/material/Dialog';",
      "import DialogActions from '@mui/material/DialogActions';",
      "import DialogContent from '@mui/material/DialogContent';",
      "import DialogContentText from '@mui/material/DialogContentText';",
      "import DialogTitle from '@mui/material/DialogTitle';",
      "import { DialogI } from 'interfaces/common';",
      "import { FastField, Form, Formik } from 'formik';",
      "import CommonStyles from 'components/CommonStyles';",
      "import TextField from 'components/CustomFields/TextField';",
      "import { useTranslation } from 'react-i18next';",
      "",
      "interface Props extends DialogI<{ username: string }> {}",
      "",
      "const $1 = (props: Props) => {",
      "  const { t } = useTranslation();",
      "  const { isOpen, toggle, onSubmit } = props;",
      "",
      "  return (",
      "    <Formik",
      "      initialValues={{ username: '' }}",
      "      validateOnChange={false}",
      "      validateOnBlur={false}",
      "      onSubmit={onSubmit ? onSubmit : () => {}}",
      "    >",
      "      {({ isSubmitting }) => {",
      "        return (",
      "          <DialogMui open={isOpen} onClose={toggle}>",
      "            <Form>",
      "              <DialogTitle>Subscribe</DialogTitle>",
      "              <DialogContent>",
      "                <DialogContentText sx={{ mb: 2 }}>",
      "                  To subscribe to this website, please enter your email address here. We will send",
      "                  updates occasionally.",
      "                </DialogContentText>",
      "                <CommonStyles.Box sx={{ width: '100%' }}>",
      "                  <FastField component={TextField} name='username' label='Username' fullWidth />",
      "                </CommonStyles.Box>",
      "              </DialogContent>",
      "              <DialogActions>",
      "                <CommonStyles.Button variant='text' onClick={toggle}>",
      "                  {t('shared:cancel')}",
      "                </CommonStyles.Button>",
      "                <CommonStyles.Button type='submit' loading={isSubmitting}>Subscribe</CommonStyles.Button>",
      "              </DialogActions>",
      "            </Form>",
      "          </DialogMui>",
      "        );",
      "      }}",
      "    </Formik>",
      "  );",
      "};",
      "",
      "export default $1;",
      ""
    ],
    "description": "genDialog"
  }
}
